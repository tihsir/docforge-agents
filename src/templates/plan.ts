/**
 * PLAN Template
 * Renders plan data to markdown
 */

import type { DocForgeState, Stage } from '../state/types.js';

/**
 * Render the PLAN document from state
 */
export function renderPlan(state: DocForgeState): string {
    const { project, documentProgress } = state;
    const plan = documentProgress.plan;

    const sections: string[] = [];

    // Header
    sections.push(`# Implementation Plan: ${project.name}`);
    sections.push('');
    sections.push(`> Generated by DocForge Agents`);
    sections.push('');

    // Overview
    sections.push('## Overview');
    sections.push('');
    sections.push(`This plan outlines the staged implementation approach for ${project.name}.`);
    sections.push(`Stack: ${project.stack.join(', ')}`);
    sections.push('');

    // Constraints
    if (project.constraints.length > 0) {
        sections.push('### Constraints');
        sections.push('');
        project.constraints.forEach(c => {
            sections.push(`- ${c}`);
        });
        sections.push('');
    }

    // Stages
    if (plan.stages && plan.stages.length > 0) {
        sections.push('---');
        sections.push('');

        for (const stage of plan.stages) {
            sections.push(renderStage(stage));
            sections.push('');
        }
    }

    return sections.join('\n');
}

/**
 * Render a single stage
 */
export function renderStage(stage: Stage): string {
    const lines: string[] = [];
    const paddedId = String(stage.id).padStart(2, '0');

    lines.push(`## Stage ${paddedId}: ${stage.name}`);
    lines.push('');

    // Deliverables
    lines.push('### Deliverables');
    lines.push('');
    stage.deliverables.forEach(d => {
        lines.push(`- [ ] ${d}`);
    });
    lines.push('');

    // Dependencies
    if (stage.dependencies.length > 0) {
        lines.push('### Dependencies');
        lines.push('');
        stage.dependencies.forEach(d => {
            lines.push(`- ${d}`);
        });
        lines.push('');
    }

    // Acceptance Criteria
    lines.push('### Acceptance Criteria');
    lines.push('');
    stage.acceptanceCriteria.forEach(c => {
        lines.push(`- [ ] ${c}`);
    });
    lines.push('');

    // Definition of Done
    lines.push('### Definition of Done');
    lines.push('');
    lines.push(stage.definitionOfDone);
    lines.push('');

    // Validation Notes
    lines.push('### Validation Notes');
    lines.push('');
    lines.push(stage.validationNotes);

    return lines.join('\n');
}

/**
 * Parse stages from PLAN.md content
 */
export function parseStages(content: string): Stage[] {
    const stages: Stage[] = [];
    const stagePattern = /## Stage (\d+): ([^\n]+)\n([\s\S]*?)(?=## Stage \d+:|$)/g;

    let match;
    while ((match = stagePattern.exec(content)) !== null) {
        const stageId = parseInt(match[1], 10);
        const stageName = match[2].trim();
        const stageContent = match[3];

        stages.push({
            id: stageId,
            name: stageName,
            deliverables: extractListItems(stageContent, /### Deliverables\s*\n([\s\S]*?)(?=###|$)/),
            dependencies: extractListItems(stageContent, /### Dependencies\s*\n([\s\S]*?)(?=###|$)/),
            acceptanceCriteria: extractListItems(stageContent, /### Acceptance Criteria\s*\n([\s\S]*?)(?=###|$)/),
            definitionOfDone: extractSection(stageContent, /### Definition of Done\s*\n([\s\S]*?)(?=###|$)/),
            validationNotes: extractSection(stageContent, /### Validation Notes\s*\n([\s\S]*?)(?=###|$)/),
        });
    }

    return stages;
}

/**
 * Extract list items from a section
 */
function extractListItems(content: string, pattern: RegExp): string[] {
    const match = pattern.exec(content);
    if (!match) return [];

    return match[1]
        .split('\n')
        .map(line => line.replace(/^[-*\[\]x ]+/, '').trim())
        .filter(line => line.length > 0);
}

/**
 * Extract section content
 */
function extractSection(content: string, pattern: RegExp): string {
    const match = pattern.exec(content);
    if (!match) return '';
    return match[1].trim();
}
