/**
 * RFC Template
 * Renders RFC data to markdown
 */

import type { DocForgeState } from '../state/types.js';

/**
 * Render the RFC document from state
 */
export function renderRfc(state: DocForgeState): string {
    const { project, documentProgress } = state;
    const rfc = documentProgress.rfc;

    const sections: string[] = [];

    // Header
    sections.push(`# RFC: ${project.name}`);
    sections.push('');
    sections.push(`> Generated by DocForge Agents`);
    sections.push(`> Stack: ${project.stack.join(', ')}`);
    sections.push('');

    // Problem Statement
    if (rfc.problem) {
        sections.push('## Problem Statement');
        sections.push('');
        sections.push(rfc.problem);
        sections.push('');
    }

    // Goals
    if (rfc.goals) {
        sections.push('## Goals');
        sections.push('');
        sections.push(rfc.goals);
        sections.push('');
    }

    // Non-Goals
    if (rfc.nonGoals) {
        sections.push('## Non-Goals');
        sections.push('');
        sections.push(rfc.nonGoals);
        sections.push('');
    }

    // Approach
    if (rfc.approach) {
        sections.push('## Proposed Approach');
        sections.push('');
        sections.push(rfc.approach);
        sections.push('');
    }

    // Interfaces & Contracts
    if (rfc.interfaces) {
        sections.push('## Interfaces & Contracts');
        sections.push('');
        sections.push(rfc.interfaces);
        sections.push('');
    }

    // Alternatives
    if (rfc.alternatives) {
        sections.push('## Alternatives Considered');
        sections.push('');
        sections.push(rfc.alternatives);
        sections.push('');
    }

    // Open Questions
    if (rfc.openQuestions) {
        sections.push('## Open Questions');
        sections.push('');
        sections.push(rfc.openQuestions);
        sections.push('');
    }

    // Assumptions
    if (rfc.assumptions) {
        sections.push('## Assumptions');
        sections.push('');
        sections.push(rfc.assumptions);
        sections.push('');
    }

    return sections.join('\n');
}

/**
 * Format goals as a markdown list
 */
export function formatGoalsList(goals: string[]): string {
    return goals.map(g => `- ${g}`).join('\n');
}

/**
 * Format alternatives as markdown sections
 */
export function formatAlternatives(
    alternatives: Array<{
        name: string;
        pros: string[];
        cons: string[];
        decision: string;
    }>
): string {
    return alternatives
        .map(alt => {
            const lines = [
                `### ${alt.name}`,
                '',
                '**Pros:**',
                ...alt.pros.map(p => `- ${p}`),
                '',
                '**Cons:**',
                ...alt.cons.map(c => `- ${c}`),
                '',
                `**Decision:** ${alt.decision}`,
            ];
            return lines.join('\n');
        })
        .join('\n\n');
}
